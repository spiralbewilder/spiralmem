import { 
  PlatformConnector, 
  PlatformVideoMetadata, 
  TranscriptData, 
  PlatformCapabilities,
  RateLimitInfo 
} from '../PlatformConnector.js';
import { 
  YouTubeVideoData, 
  YouTubeTranscript, 
  YouTubeTranscriptSegment,
  YouTubeUrlParts 
} from '../../models/types.js';
import { ErrorRecoveryManager, ErrorContext } from '../ErrorRecovery.js';
import { PerformanceMonitor } from '../PerformanceMonitor.js';

/**
 * YouTube platform connector implementation
 * Provides metadata extraction, transcript retrieval, and deep-link generation for YouTube videos
 */
export class YouTubeConnector extends PlatformConnector {
  readonly platform = 'youtube';
  readonly capabilities: PlatformCapabilities = {
    canExtractMetadata: true,
    canExtractTranscript: true,
    canGenerateDeepLinks: true,
    canAccessComments: true,
    canAccessPlaylists: true,
    canBatchProcess: true,
    supportsLiveContent: false, // Live streams not supported for transcription
    supportedLanguages: ['en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'ko', 'zh'],
    maxBatchSize: 50
  };

  protected readonly apiKey: string;
  protected readonly baseUrl = 'https://www.googleapis.com/youtube/v3';
  protected readonly errorRecovery = new ErrorRecoveryManager();
  protected readonly performanceMonitor = new PerformanceMonitor();

  constructor(credentials?: Record<string, any>) {
    super(credentials);
    
    this.apiKey = credentials?.apiKey || process.env.YOUTUBE_API_KEY || '';
    if (!this.apiKey) {
      console.warn('YouTube API key not provided. Some features may not work.');
    }
  }

  protected getDefaultRateLimits(): RateLimitInfo {
    const now = new Date();
    return {
      requestsPerMinute: 100,
      requestsPerHour: 10000,
      requestsPerDay: 1000000,
      currentMinuteUsage: 0,
      currentHourUsage: 0,
      currentDayUsage: 0,
      resetTimes: {
        nextMinute: new Date(now.getTime() + 60000),
        nextHour: new Date(now.getTime() + 3600000),
        nextDay: new Date(now.getTime() + 86400000),
      }
    };
  }

  async extractMetadata(url: string): Promise<PlatformVideoMetadata> {
    const operationId = `extractMetadata-${Date.now()}`;
    this.performanceMonitor.startOperation(operationId);

    const urlParts = this.parseUrl(url);
    if (!urlParts.isValid || !urlParts.videoId) {
      throw new Error(`Invalid YouTube URL: ${url}`);
    }

    await this.waitForRateLimit();
    
    try {
      const videoData = await this.getVideoData(urlParts.videoId);
      await this.recordApiCall();

      // Record successful API call
      this.performanceMonitor.recordMetric({
        name: 'api.call.success',
        value: 1,
        unit: 'count',
        timestamp: new Date(),
        tags: { platform: this.platform, operation: 'extractMetadata', success: 'true' }
      });

      const result = this.convertToStandardMetadata(videoData);
      this.performanceMonitor.endOperation(operationId, this.platform, true);
      
      return result;
    } catch (error) {
      // Record failed API call
      this.performanceMonitor.recordMetric({
        name: 'api.call.failed',
        value: 1,
        unit: 'count',
        timestamp: new Date(),
        tags: { platform: this.platform, operation: 'extractMetadata', success: 'false' }
      });

      // Use error recovery system
      const context: ErrorContext = {
        operation: 'extractMetadata',
        platform: this.platform,
        resourceId: urlParts.videoId,
        timestamp: new Date(),
        userAction: `Extract metadata for ${url}`
      };

      const recovery = await this.errorRecovery.handleError(error as Error, context);
      
      if (recovery.recovered && recovery.result) {
        this.performanceMonitor.endOperation(operationId, this.platform, true);
        return recovery.result;
      }

      this.performanceMonitor.endOperation(operationId, this.platform, false);
      throw this.handleApiError(error, 'extractMetadata');
    }
  }

  async extractTranscript(videoId: string, language = 'en'): Promise<TranscriptData> {
    await this.waitForRateLimit();

    try {
      // Try to get official transcript first
      let transcript = await this.getOfficialTranscript(videoId, language);
      
      // Fall back to auto-generated if official not available
      if (!transcript) {
        transcript = await this.getAutoGeneratedTranscript(videoId, language);
      }

      if (!transcript) {
        throw new Error(`No transcript available for video ${videoId} in language ${language}`);
      }

      await this.recordApiCall();
      return transcript;
    } catch (error) {
      throw this.handleApiError(error, 'extractTranscript');
    }
  }

  generateDeepLink(videoId: string, timestamp: number): string {
    const minutes = Math.floor(timestamp / 60);
    const seconds = timestamp % 60;
    
    // Format: https://youtu.be/VIDEO_ID?t=123s or https://youtube.com/watch?v=VIDEO_ID&t=123s
    if (minutes > 0) {
      return `https://youtu.be/${videoId}?t=${minutes}m${seconds}s`;
    } else {
      return `https://youtu.be/${videoId}?t=${timestamp}s`;
    }
  }

  generatePlaylistDeepLink(playlistId: string, videoId: string, timestamp?: number): string {
    let url = `https://youtube.com/watch?v=${videoId}&list=${playlistId}`;
    if (timestamp) {
      url += `&t=${timestamp}s`;
    }
    return url;
  }

  validateUrl(url: string): boolean {
    return this.parseUrl(url).isValid;
  }

  extractVideoId(url: string): string {
    const urlParts = this.parseUrl(url);
    if (!urlParts.isValid || !urlParts.videoId) {
      throw new Error(`Cannot extract video ID from URL: ${url}`);
    }
    return urlParts.videoId;
  }

  parseUrl(url: string): YouTubeUrlParts {
    const patterns = [
      // Standard watch URL
      { 
        pattern: /(?:youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})(?:.*?&list=([a-zA-Z0-9_-]+))?(?:.*?[&?]t=(\d+))?/,
        groups: { videoId: 1, playlistId: 2, timestamp: 3 }
      },
      // Shortened URL
      { 
        pattern: /(?:youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\?.*?list=([a-zA-Z0-9_-]+))?(?:.*?[&?]t=(\d+))?/,
        groups: { videoId: 1, playlistId: 2, timestamp: 3 }
      },
      // Embed URL
      { 
        pattern: /(?:youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})(?:\?.*?start=(\d+))?/,
        groups: { videoId: 1, timestamp: 2 }
      },
      // Playlist URL
      { 
        pattern: /(?:youtube\.com\/playlist\?list=)([a-zA-Z0-9_-]+)/,
        groups: { playlistId: 1 }
      },
      // Channel URL
      { 
        pattern: /(?:youtube\.com\/(?:channel\/|c\/|user\/))([a-zA-Z0-9_-]+)/,
        groups: { channelId: 1 }
      }
    ];

    for (const { pattern, groups } of patterns) {
      const match = url.match(pattern);
      if (match) {
        return {
          videoId: groups.videoId ? match[groups.videoId] : undefined,
          playlistId: groups.playlistId ? match[groups.playlistId] : undefined,
          timestamp: groups.timestamp ? parseInt(match[groups.timestamp], 10) : undefined,
          channelId: groups.channelId ? match[groups.channelId] : undefined,
          isValid: true
        };
      }
    }

    return { isValid: false };
  }

  async getVideoData(videoId: string): Promise<YouTubeVideoData> {
    if (!this.apiKey) {
      throw new Error('YouTube API key required for metadata extraction');
    }

    const url = `${this.baseUrl}/videos?part=snippet,contentDetails,statistics&id=${videoId}&key=${this.apiKey}`;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json() as any;
    if (!data.items || data.items.length === 0) {
      throw new Error(`Video not found: ${videoId}`);
    }

    const item = data.items[0];
    const snippet = item.snippet;
    const contentDetails = item.contentDetails;
    const statistics = item.statistics;

    return {
      videoId,
      title: snippet.title,
      description: snippet.description,
      duration: this.parseDuration(contentDetails.duration),
      uploadDate: new Date(snippet.publishedAt),
      channelId: snippet.channelId,
      channelTitle: snippet.channelTitle,
      viewCount: statistics.viewCount ? parseInt(statistics.viewCount, 10) : undefined,
      likeCount: statistics.likeCount ? parseInt(statistics.likeCount, 10) : undefined,
      commentCount: statistics.commentCount ? parseInt(statistics.commentCount, 10) : undefined,
      tags: snippet.tags || [],
      categoryId: snippet.categoryId,
      defaultLanguage: snippet.defaultLanguage,
      thumbnails: {
        default: snippet.thumbnails.default?.url || '',
        medium: snippet.thumbnails.medium?.url || '',
        high: snippet.thumbnails.high?.url || '',
        maxres: snippet.thumbnails.maxres?.url
      }
    };
  }

  private async getOfficialTranscript(videoId: string, language: string): Promise<TranscriptData | null> {
    // Note: YouTube's official transcript API requires OAuth and channel ownership
    // For now, we'll use a fallback approach or third-party libraries
    // This is a placeholder for the actual implementation
    
    try {
      // In a real implementation, you would use youtube-transcript or similar library
      // const transcript = await youtubeTranscript.getTranscript(videoId, { lang: language });
      
      // For now, return null to fall back to auto-generated
      return null;
    } catch (error) {
      return null;
    }
  }

  private async getAutoGeneratedTranscript(videoId: string, language: string): Promise<TranscriptData | null> {
    try {
      // This would use a library like youtube-transcript
      // const transcript = await youtubeTranscript.getTranscript(videoId, { lang: language, country: 'US' });
      
      // Placeholder implementation - in real scenario, use youtube-transcript npm package
      return {
        videoId,
        language,
        segments: [],
        isGenerated: true,
        source: 'api'
      };
    } catch (error) {
      return null;
    }
  }

  async extractComments(videoId: string, maxCount = 100): Promise<Array<{
    id: string;
    text: string;
    author: string;
    timestamp: Date;
    likeCount?: number;
    replies?: any[];
  }>> {
    if (!this.apiKey) {
      throw new Error('YouTube API key required for comment extraction');
    }

    await this.waitForRateLimit();

    try {
      const url = `${this.baseUrl}/commentThreads?part=snippet,replies&videoId=${videoId}&maxResults=${Math.min(maxCount, 100)}&key=${this.apiKey}`;
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as any;
      await this.recordApiCall();

      return data.items?.map((item: any) => ({
        id: item.id,
        text: item.snippet.topLevelComment.snippet.textDisplay,
        author: item.snippet.topLevelComment.snippet.authorDisplayName,
        timestamp: new Date(item.snippet.topLevelComment.snippet.publishedAt),
        likeCount: item.snippet.topLevelComment.snippet.likeCount,
        replies: item.replies?.comments?.map((reply: any) => ({
          id: reply.id,
          text: reply.snippet.textDisplay,
          author: reply.snippet.authorDisplayName,
          timestamp: new Date(reply.snippet.publishedAt),
          likeCount: reply.snippet.likeCount
        })) || []
      })) || [];
    } catch (error) {
      throw this.handleApiError(error, 'extractComments');
    }
  }

  async extractPlaylistVideos(playlistId: string): Promise<string[]> {
    if (!this.apiKey) {
      throw new Error('YouTube API key required for playlist extraction');
    }

    await this.waitForRateLimit();

    try {
      const videoIds: string[] = [];
      let nextPageToken = '';

      do {
        const url = `${this.baseUrl}/playlistItems?part=contentDetails&playlistId=${playlistId}&maxResults=50${nextPageToken ? `&pageToken=${nextPageToken}` : ''}&key=${this.apiKey}`;
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json() as any;
        await this.recordApiCall();

        if (data.items) {
          videoIds.push(...data.items.map((item: any) => item.contentDetails.videoId));
        }

        nextPageToken = data.nextPageToken || '';
      } while (nextPageToken);

      return videoIds;
    } catch (error) {
      throw this.handleApiError(error, 'extractPlaylistVideos');
    }
  }

  async searchVideos(query: string, maxResults = 25): Promise<PlatformVideoMetadata[]> {
    if (!this.apiKey) {
      throw new Error('YouTube API key required for video search');
    }

    await this.waitForRateLimit();

    try {
      const url = `${this.baseUrl}/search?part=snippet&q=${encodeURIComponent(query)}&type=video&maxResults=${maxResults}&key=${this.apiKey}`;
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as any;
      await this.recordApiCall();

      if (!data.items) {
        return [];
      }

      // Get detailed info for each video
      const videoIds = data.items.map((item: any) => item.id.videoId);
      const detailedVideos = await this.batchGetVideoData(videoIds);

      return detailedVideos.map(video => this.convertToStandardMetadata(video));
    } catch (error) {
      throw this.handleApiError(error, 'searchVideos');
    }
  }

  protected async batchGetVideoData(videoIds: string[]): Promise<YouTubeVideoData[]> {
    const results: YouTubeVideoData[] = [];
    const batchSize = 50; // YouTube API limit

    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      const idsParam = batch.join(',');
      
      await this.waitForRateLimit();
      
      const url = `${this.baseUrl}/videos?part=snippet,contentDetails,statistics&id=${idsParam}&key=${this.apiKey}`;
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as any;
      await this.recordApiCall();

      if (data.items) {
        for (const item of data.items) {
          const snippet = item.snippet;
          const contentDetails = item.contentDetails;
          const statistics = item.statistics;

          results.push({
            videoId: item.id,
            title: snippet.title,
            description: snippet.description,
            duration: this.parseDuration(contentDetails.duration),
            uploadDate: new Date(snippet.publishedAt),
            channelId: snippet.channelId,
            channelTitle: snippet.channelTitle,
            viewCount: statistics.viewCount ? parseInt(statistics.viewCount, 10) : undefined,
            likeCount: statistics.likeCount ? parseInt(statistics.likeCount, 10) : undefined,
            commentCount: statistics.commentCount ? parseInt(statistics.commentCount, 10) : undefined,
            tags: snippet.tags || [],
            categoryId: snippet.categoryId,
            defaultLanguage: snippet.defaultLanguage,
            thumbnails: {
              default: snippet.thumbnails.default?.url || '',
              medium: snippet.thumbnails.medium?.url || '',
              high: snippet.thumbnails.high?.url || '',
              maxres: snippet.thumbnails.maxres?.url
            }
          });
        }
      }
    }

    return results;
  }

  protected convertToStandardMetadata(videoData: YouTubeVideoData): PlatformVideoMetadata {
    return {
      videoId: videoData.videoId,
      title: videoData.title,
      description: videoData.description,
      duration: videoData.duration,
      uploadDate: videoData.uploadDate,
      thumbnailUrl: videoData.thumbnails.high || videoData.thumbnails.medium || videoData.thumbnails.default,
      tags: videoData.tags,
      channelInfo: {
        id: videoData.channelId,
        name: videoData.channelTitle
      },
      viewCount: videoData.viewCount,
      likeCount: videoData.likeCount,
      commentCount: videoData.commentCount,
      language: videoData.defaultLanguage,
      category: videoData.categoryId,
      accessibility: {
        hasClosedCaptions: false, // Would need to check captions endpoint
        hasAutoGeneratedCaptions: true, // Most YouTube videos have auto-generated
        supportedLanguages: ['en'] // Default, would need to check actual captions
      }
    };
  }

  private parseDuration(isoDuration: string): number {
    // Parse ISO 8601 duration (PT4M13S) to seconds
    const match = isoDuration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || '0', 10);
    const minutes = parseInt(match[2] || '0', 10);
    const seconds = parseInt(match[3] || '0', 10);

    return hours * 3600 + minutes * 60 + seconds;
  }

  async healthCheck(): Promise<{
    platform: string;
    isHealthy: boolean;
    rateLimitStatus: {
      withinLimits: boolean;
      usage: {
        minute: number;
        hour: number;
        day: number;
      };
    };
    errorAnalytics: {
      totalErrors: number;
      recoverySuccessRate: number;
      recentErrors: number;
    };
    lastError?: string;
  }> {
    const baseHealth = await super.healthCheck();
    const analytics = this.errorRecovery.getErrorAnalytics();
    
    // Calculate recent errors (last hour)
    const oneHourAgo = Date.now() - 3600000;
    const recentErrors = analytics.totalErrors; // Simplified for now
    
    try {
      // Test API connectivity with a simple request
      if (this.apiKey) {
        await this.waitForRateLimit();
        const response = await fetch(`${this.baseUrl}/videos?part=snippet&id=dQw4w9WgXcQ&key=${this.apiKey}`);
        const isHealthy = response.ok;
        await this.recordApiCall();

        return {
          ...baseHealth,
          isHealthy,
          errorAnalytics: {
            totalErrors: analytics.totalErrors,
            recoverySuccessRate: analytics.recoverySuccessRate,
            recentErrors
          },
          lastError: isHealthy ? undefined : `API test failed: ${response.status}`
        };
      } else {
        return {
          ...baseHealth,
          isHealthy: false,
          errorAnalytics: {
            totalErrors: analytics.totalErrors,
            recoverySuccessRate: analytics.recoverySuccessRate,
            recentErrors
          },
          lastError: 'No API key configured'
        };
      }
    } catch (error) {
      return {
        ...baseHealth,
        isHealthy: false,
        errorAnalytics: {
          totalErrors: analytics.totalErrors,
          recoverySuccessRate: analytics.recoverySuccessRate,
          recentErrors
        },
        lastError: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Get error analytics and prevention recommendations
   */
  getErrorAnalytics() {
    return this.errorRecovery.getErrorAnalytics();
  }

  /**
   * Get preemptive error prevention analysis
   */
  async getErrorPrevention(operation: string) {
    return this.errorRecovery.preventErrors(operation, this.platform);
  }

  /**
   * Export error data for analysis
   */
  exportErrorData() {
    return this.errorRecovery.exportErrorData();
  }

  /**
   * Clean up old error history
   */
  cleanupErrorHistory(maxAge?: number) {
    this.errorRecovery.cleanupHistory(maxAge);
  }

  /**
   * Get performance analytics
   */
  getPerformanceAnalytics(timeRange?: number) {
    return this.performanceMonitor.getAnalytics(timeRange);
  }

  /**
   * Get real-time performance status
   */
  getPerformanceStatus() {
    return this.performanceMonitor.getRealtimeStatus();
  }

  /**
   * Take a performance snapshot
   */
  takePerformanceSnapshot(operation: string) {
    return this.performanceMonitor.takeSnapshot(this.platform, operation);
  }

  /**
   * Export performance data
   */
  exportPerformanceData() {
    return this.performanceMonitor.exportData();
  }

  /**
   * Record custom performance metric
   */
  recordCustomMetric(name: string, value: number, unit: 'ms' | 'bytes' | 'count' | 'percent' | 'rate', tags?: Record<string, string>) {
    this.performanceMonitor.recordMetric({
      name,
      value,
      unit,
      timestamp: new Date(),
      tags: { platform: this.platform, ...tags }
    });
  }
}