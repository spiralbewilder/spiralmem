import { 
  PlatformConnector, 
  PlatformVideoMetadata, 
  TranscriptData, 
  PlatformCapabilities,
  RateLimitInfo 
} from '../PlatformConnector.js';
import { 
  YouTubeVideoData, 
  YouTubeTranscript, 
  YouTubeTranscriptSegment,
  YouTubeUrlParts 
} from '../../models/types.js';
import { ErrorRecoveryManager, ErrorContext } from '../ErrorRecovery.js';
import { PerformanceMonitor } from '../PerformanceMonitor.js';
import { logger } from '../../../utils/logger.js';
import { spawn } from 'child_process';
import path from 'path';

/**
 * YouTube platform connector implementation
 * Provides metadata extraction, transcript retrieval, and deep-link generation for YouTube videos
 */
export class YouTubeConnector extends PlatformConnector {
  readonly platform = 'youtube';
  readonly capabilities: PlatformCapabilities = {
    canExtractMetadata: true,
    canExtractTranscript: true,
    canGenerateDeepLinks: true,
    canAccessComments: true,
    canAccessPlaylists: true,
    canBatchProcess: true,
    supportsLiveContent: false, // Live streams not supported for transcription
    supportedLanguages: ['en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'ko', 'zh'],
    maxBatchSize: 50
  };

  protected readonly apiKey: string;
  protected readonly baseUrl = 'https://www.googleapis.com/youtube/v3';
  protected readonly errorRecovery = new ErrorRecoveryManager();
  protected readonly performanceMonitor = new PerformanceMonitor();

  constructor(credentials?: Record<string, any>) {
    super(credentials);
    
    this.apiKey = credentials?.apiKey || process.env.YOUTUBE_API_KEY || '';
    if (!this.apiKey) {
      console.warn('YouTube API key not provided. Some features may not work.');
    }
  }

  protected getDefaultRateLimits(): RateLimitInfo {
    const now = new Date();
    return {
      requestsPerMinute: 100,
      requestsPerHour: 10000,
      requestsPerDay: 1000000,
      currentMinuteUsage: 0,
      currentHourUsage: 0,
      currentDayUsage: 0,
      resetTimes: {
        nextMinute: new Date(now.getTime() + 60000),
        nextHour: new Date(now.getTime() + 3600000),
        nextDay: new Date(now.getTime() + 86400000),
      }
    };
  }

  async extractMetadata(url: string): Promise<PlatformVideoMetadata> {
    const operationId = `extractMetadata-${Date.now()}`;
    this.performanceMonitor.startOperation(operationId);

    const urlParts = this.parseUrl(url);
    if (!urlParts.isValid || !urlParts.videoId) {
      throw new Error(`Invalid YouTube URL: ${url}`);
    }

    await this.waitForRateLimit();
    
    try {
      const videoData = await this.getVideoData(urlParts.videoId);
      await this.recordApiCall();

      // Record successful API call
      this.performanceMonitor.recordMetric({
        name: 'api.call.success',
        value: 1,
        unit: 'count',
        timestamp: new Date(),
        tags: { platform: this.platform, operation: 'extractMetadata', success: 'true' }
      });

      const result = this.convertToStandardMetadata(videoData);
      this.performanceMonitor.endOperation(operationId, this.platform, true);
      
      return result;
    } catch (error) {
      // Record failed API call
      this.performanceMonitor.recordMetric({
        name: 'api.call.failed',
        value: 1,
        unit: 'count',
        timestamp: new Date(),
        tags: { platform: this.platform, operation: 'extractMetadata', success: 'false' }
      });

      // Use error recovery system
      const context: ErrorContext = {
        operation: 'extractMetadata',
        platform: this.platform,
        resourceId: urlParts.videoId,
        timestamp: new Date(),
        userAction: `Extract metadata for ${url}`
      };

      const recovery = await this.errorRecovery.handleError(error as Error, context);
      
      if (recovery.recovered && recovery.result) {
        this.performanceMonitor.endOperation(operationId, this.platform, true);
        return recovery.result;
      }

      this.performanceMonitor.endOperation(operationId, this.platform, false);
      throw this.handleApiError(error, 'extractMetadata');
    }
  }

  async extractTranscript(videoId: string, language = 'en'): Promise<TranscriptData> {
    await this.waitForRateLimit();

    try {
      // Try to get official transcript first
      let transcript = await this.getOfficialTranscript(videoId, language);
      
      // Fall back to auto-generated if official not available
      if (!transcript) {
        transcript = await this.getAutoGeneratedTranscript(videoId, language);
      }

      if (!transcript) {
        throw new Error(`No transcript available for video ${videoId} in language ${language}`);
      }

      await this.recordApiCall();
      return transcript;
    } catch (error) {
      throw this.handleApiError(error, 'extractTranscript');
    }
  }

  generateDeepLink(videoId: string, timestamp: number): string {
    const minutes = Math.floor(timestamp / 60);
    const seconds = timestamp % 60;
    
    // Format: https://youtu.be/VIDEO_ID?t=123s or https://youtube.com/watch?v=VIDEO_ID&t=123s
    if (minutes > 0) {
      return `https://youtu.be/${videoId}?t=${minutes}m${seconds}s`;
    } else {
      return `https://youtu.be/${videoId}?t=${timestamp}s`;
    }
  }

  generatePlaylistDeepLink(playlistId: string, videoId: string, timestamp?: number): string {
    let url = `https://youtube.com/watch?v=${videoId}&list=${playlistId}`;
    if (timestamp) {
      url += `&t=${timestamp}s`;
    }
    return url;
  }

  validateUrl(url: string): boolean {
    return this.parseUrl(url).isValid;
  }

  extractVideoId(url: string): string {
    const urlParts = this.parseUrl(url);
    if (!urlParts.isValid || !urlParts.videoId) {
      throw new Error(`Cannot extract video ID from URL: ${url}`);
    }
    return urlParts.videoId;
  }

  parseUrl(url: string): YouTubeUrlParts {
    const patterns = [
      // Standard watch URL
      { 
        pattern: /(?:youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})(?:.*?&list=([a-zA-Z0-9_-]+))?(?:.*?[&?]t=(\d+))?/,
        groups: { videoId: 1, playlistId: 2, timestamp: 3 }
      },
      // Shortened URL
      { 
        pattern: /(?:youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\?.*?list=([a-zA-Z0-9_-]+))?(?:.*?[&?]t=(\d+))?/,
        groups: { videoId: 1, playlistId: 2, timestamp: 3 }
      },
      // Embed URL
      { 
        pattern: /(?:youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})(?:\?.*?start=(\d+))?/,
        groups: { videoId: 1, timestamp: 2 }
      },
      // Playlist URL
      { 
        pattern: /(?:youtube\.com\/playlist\?list=)([a-zA-Z0-9_-]+)/,
        groups: { playlistId: 1 }
      },
      // Channel URL
      { 
        pattern: /(?:youtube\.com\/(?:channel\/|c\/|user\/))([a-zA-Z0-9_-]+)/,
        groups: { channelId: 1 }
      }
    ];

    for (const { pattern, groups } of patterns) {
      const match = url.match(pattern);
      if (match) {
        return {
          videoId: groups.videoId ? match[groups.videoId] : undefined,
          playlistId: groups.playlistId ? match[groups.playlistId] : undefined,
          timestamp: groups.timestamp ? parseInt(match[groups.timestamp], 10) : undefined,
          channelId: groups.channelId ? match[groups.channelId] : undefined,
          isValid: true
        };
      }
    }

    return { isValid: false };
  }

  async getVideoData(videoId: string): Promise<YouTubeVideoData> {
    if (!this.apiKey) {
      throw new Error('YouTube API key required for metadata extraction');
    }

    const url = `${this.baseUrl}/videos?part=snippet,contentDetails,statistics&id=${videoId}&key=${this.apiKey}`;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json() as any;
    if (!data.items || data.items.length === 0) {
      throw new Error(`Video not found: ${videoId}`);
    }

    const item = data.items[0];
    const snippet = item.snippet;
    const contentDetails = item.contentDetails;
    const statistics = item.statistics;

    return {
      videoId,
      title: snippet.title,
      description: snippet.description,
      duration: this.parseDuration(contentDetails.duration),
      uploadDate: new Date(snippet.publishedAt),
      channelId: snippet.channelId,
      channelTitle: snippet.channelTitle,
      viewCount: statistics.viewCount ? parseInt(statistics.viewCount, 10) : undefined,
      likeCount: statistics.likeCount ? parseInt(statistics.likeCount, 10) : undefined,
      commentCount: statistics.commentCount ? parseInt(statistics.commentCount, 10) : undefined,
      tags: snippet.tags || [],
      categoryId: snippet.categoryId,
      defaultLanguage: snippet.defaultLanguage,
      thumbnails: {
        default: snippet.thumbnails.default?.url || '',
        medium: snippet.thumbnails.medium?.url || '',
        high: snippet.thumbnails.high?.url || '',
        maxres: snippet.thumbnails.maxres?.url
      }
    };
  }

  private async getOfficialTranscript(videoId: string, language: string): Promise<TranscriptData | null> {
    // Note: YouTube's official transcript API requires OAuth and channel ownership
    // For now, we'll use a fallback approach or third-party libraries
    // This is a placeholder for the actual implementation
    
    try {
      // In a real implementation, you would use youtube-transcript or similar library
      // const transcript = await youtubeTranscript.getTranscript(videoId, { lang: language });
      
      // For now, return null to fall back to auto-generated
      return null;
    } catch (error) {
      return null;
    }
  }

  private async getAutoGeneratedTranscript(videoId: string, language: string): Promise<TranscriptData | null> {
    try {
      // This would use a library like youtube-transcript
      // const transcript = await youtubeTranscript.getTranscript(videoId, { lang: language, country: 'US' });
      
      // Placeholder implementation - in real scenario, use youtube-transcript npm package
      return {
        videoId,
        language,
        segments: [],
        isGenerated: true,
        source: 'api'
      };
    } catch (error) {
      return null;
    }
  }

  async extractComments(videoId: string, maxCount = 100): Promise<Array<{
    id: string;
    text: string;
    author: string;
    timestamp: Date;
    likeCount?: number;
    replies?: any[];
  }>> {
    if (!this.apiKey) {
      throw new Error('YouTube API key required for comment extraction');
    }

    await this.waitForRateLimit();

    try {
      const url = `${this.baseUrl}/commentThreads?part=snippet,replies&videoId=${videoId}&maxResults=${Math.min(maxCount, 100)}&key=${this.apiKey}`;
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as any;
      await this.recordApiCall();

      return data.items?.map((item: any) => ({
        id: item.id,
        text: item.snippet.topLevelComment.snippet.textDisplay,
        author: item.snippet.topLevelComment.snippet.authorDisplayName,
        timestamp: new Date(item.snippet.topLevelComment.snippet.publishedAt),
        likeCount: item.snippet.topLevelComment.snippet.likeCount,
        replies: item.replies?.comments?.map((reply: any) => ({
          id: reply.id,
          text: reply.snippet.textDisplay,
          author: reply.snippet.authorDisplayName,
          timestamp: new Date(reply.snippet.publishedAt),
          likeCount: reply.snippet.likeCount
        })) || []
      })) || [];
    } catch (error) {
      throw this.handleApiError(error, 'extractComments');
    }
  }

  async extractPlaylistVideos(playlistId: string): Promise<string[]> {
    if (!this.apiKey) {
      throw new Error('YouTube API key required for playlist extraction');
    }

    await this.waitForRateLimit();

    try {
      const videoIds: string[] = [];
      let nextPageToken = '';

      do {
        const url = `${this.baseUrl}/playlistItems?part=contentDetails&playlistId=${playlistId}&maxResults=50${nextPageToken ? `&pageToken=${nextPageToken}` : ''}&key=${this.apiKey}`;
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json() as any;
        await this.recordApiCall();

        if (data.items) {
          videoIds.push(...data.items.map((item: any) => item.contentDetails.videoId));
        }

        nextPageToken = data.nextPageToken || '';
      } while (nextPageToken);

      return videoIds;
    } catch (error) {
      throw this.handleApiError(error, 'extractPlaylistVideos');
    }
  }

  async searchVideos(query: string, maxResults = 25): Promise<PlatformVideoMetadata[]> {
    if (!this.apiKey) {
      throw new Error('YouTube API key required for video search');
    }

    await this.waitForRateLimit();

    try {
      const url = `${this.baseUrl}/search?part=snippet&q=${encodeURIComponent(query)}&type=video&maxResults=${maxResults}&key=${this.apiKey}`;
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as any;
      await this.recordApiCall();

      if (!data.items) {
        return [];
      }

      // Get detailed info for each video
      const videoIds = data.items.map((item: any) => item.id.videoId);
      const detailedVideos = await this.batchGetVideoData(videoIds);

      return detailedVideos.map(video => this.convertToStandardMetadata(video));
    } catch (error) {
      throw this.handleApiError(error, 'searchVideos');
    }
  }

  protected async batchGetVideoData(videoIds: string[]): Promise<YouTubeVideoData[]> {
    const results: YouTubeVideoData[] = [];
    const batchSize = 50; // YouTube API limit

    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      const idsParam = batch.join(',');
      
      await this.waitForRateLimit();
      
      const url = `${this.baseUrl}/videos?part=snippet,contentDetails,statistics&id=${idsParam}&key=${this.apiKey}`;
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as any;
      await this.recordApiCall();

      if (data.items) {
        for (const item of data.items) {
          const snippet = item.snippet;
          const contentDetails = item.contentDetails;
          const statistics = item.statistics;

          results.push({
            videoId: item.id,
            title: snippet.title,
            description: snippet.description,
            duration: this.parseDuration(contentDetails.duration),
            uploadDate: new Date(snippet.publishedAt),
            channelId: snippet.channelId,
            channelTitle: snippet.channelTitle,
            viewCount: statistics.viewCount ? parseInt(statistics.viewCount, 10) : undefined,
            likeCount: statistics.likeCount ? parseInt(statistics.likeCount, 10) : undefined,
            commentCount: statistics.commentCount ? parseInt(statistics.commentCount, 10) : undefined,
            tags: snippet.tags || [],
            categoryId: snippet.categoryId,
            defaultLanguage: snippet.defaultLanguage,
            thumbnails: {
              default: snippet.thumbnails.default?.url || '',
              medium: snippet.thumbnails.medium?.url || '',
              high: snippet.thumbnails.high?.url || '',
              maxres: snippet.thumbnails.maxres?.url
            }
          });
        }
      }
    }

    return results;
  }

  protected convertToStandardMetadata(videoData: YouTubeVideoData): PlatformVideoMetadata {
    return {
      videoId: videoData.videoId,
      title: videoData.title,
      description: videoData.description,
      duration: videoData.duration,
      uploadDate: videoData.uploadDate,
      thumbnailUrl: videoData.thumbnails.high || videoData.thumbnails.medium || videoData.thumbnails.default,
      tags: videoData.tags,
      channelInfo: {
        id: videoData.channelId,
        name: videoData.channelTitle
      },
      viewCount: videoData.viewCount,
      likeCount: videoData.likeCount,
      commentCount: videoData.commentCount,
      language: videoData.defaultLanguage,
      category: videoData.categoryId,
      accessibility: {
        hasClosedCaptions: false, // Would need to check captions endpoint
        hasAutoGeneratedCaptions: true, // Most YouTube videos have auto-generated
        supportedLanguages: ['en'] // Default, would need to check actual captions
      }
    };
  }

  private parseDuration(isoDuration: string): number {
    // Parse ISO 8601 duration (PT4M13S) to seconds
    const match = isoDuration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || '0', 10);
    const minutes = parseInt(match[2] || '0', 10);
    const seconds = parseInt(match[3] || '0', 10);

    return hours * 3600 + minutes * 60 + seconds;
  }

  async healthCheck(): Promise<{
    platform: string;
    isHealthy: boolean;
    rateLimitStatus: {
      withinLimits: boolean;
      usage: {
        minute: number;
        hour: number;
        day: number;
      };
    };
    errorAnalytics: {
      totalErrors: number;
      recoverySuccessRate: number;
      recentErrors: number;
    };
    lastError?: string;
  }> {
    const baseHealth = await super.healthCheck();
    const analytics = this.errorRecovery.getErrorAnalytics();
    
    // Calculate recent errors (last hour)
    const oneHourAgo = Date.now() - 3600000;
    const recentErrors = analytics.totalErrors; // Simplified for now
    
    try {
      // Test API connectivity with a simple request
      if (this.apiKey) {
        await this.waitForRateLimit();
        const response = await fetch(`${this.baseUrl}/videos?part=snippet&id=dQw4w9WgXcQ&key=${this.apiKey}`);
        const isHealthy = response.ok;
        await this.recordApiCall();

        return {
          ...baseHealth,
          isHealthy,
          errorAnalytics: {
            totalErrors: analytics.totalErrors,
            recoverySuccessRate: analytics.recoverySuccessRate,
            recentErrors
          },
          lastError: isHealthy ? undefined : `API test failed: ${response.status}`
        };
      } else {
        return {
          ...baseHealth,
          isHealthy: false,
          errorAnalytics: {
            totalErrors: analytics.totalErrors,
            recoverySuccessRate: analytics.recoverySuccessRate,
            recentErrors
          },
          lastError: 'No API key configured'
        };
      }
    } catch (error) {
      return {
        ...baseHealth,
        isHealthy: false,
        errorAnalytics: {
          totalErrors: analytics.totalErrors,
          recoverySuccessRate: analytics.recoverySuccessRate,
          recentErrors
        },
        lastError: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Get error analytics and prevention recommendations
   */
  getErrorAnalytics() {
    return this.errorRecovery.getErrorAnalytics();
  }

  /**
   * Get preemptive error prevention analysis
   */
  async getErrorPrevention(operation: string) {
    return this.errorRecovery.preventErrors(operation, this.platform);
  }

  /**
   * Export error data for analysis
   */
  exportErrorData() {
    return this.errorRecovery.exportErrorData();
  }

  /**
   * Clean up old error history
   */
  cleanupErrorHistory(maxAge?: number) {
    this.errorRecovery.cleanupHistory(maxAge);
  }

  /**
   * Get performance analytics
   */
  getPerformanceAnalytics(timeRange?: number) {
    return this.performanceMonitor.getAnalytics(timeRange);
  }

  /**
   * Get real-time performance status
   */
  getPerformanceStatus() {
    return this.performanceMonitor.getRealtimeStatus();
  }

  /**
   * Take a performance snapshot
   */
  takePerformanceSnapshot(operation: string) {
    return this.performanceMonitor.takeSnapshot(this.platform, operation);
  }

  /**
   * Export performance data
   */
  exportPerformanceData() {
    return this.performanceMonitor.exportData();
  }

  /**
   * Record custom performance metric
   */
  recordCustomMetric(name: string, value: number, unit: 'ms' | 'bytes' | 'count' | 'percent' | 'rate', tags?: Record<string, string>) {
    this.performanceMonitor.recordMetric({
      name,
      value,
      unit,
      timestamp: new Date(),
      tags: { platform: this.platform, ...tags }
    });
  }

  /**
   * Get channel information
   */
  async getChannelInfo(channelId: string): Promise<any> {
    const apiKey = process.env.YOUTUBE_API_KEY;
    
    if (apiKey) {
      try {
        const url = `${this.baseUrl}/channels?part=snippet,statistics&id=${channelId}&key=${apiKey}`;
        const response = await fetch(url);
        
        if (response.ok) {
          const data = await response.json() as any;
          if (data.items && data.items.length > 0) {
            const item = data.items[0];
            const snippet = item.snippet;
            const statistics = item.statistics;
            
            return {
              id: channelId,
              title: snippet.title,
              description: snippet.description || '',
              subscriberCount: parseInt(statistics.subscriberCount || '0'),
              videoCount: parseInt(statistics.videoCount || '0'),
              viewCount: parseInt(statistics.viewCount || '0'),
              customUrl: snippet.customUrl,
              thumbnails: snippet.thumbnails
            };
          }
        }
      } catch (error) {
        logger.warn(`YouTube API channel info failed, using yt-dlp fallback:`, error);
      }
    }
    
    // Fallback: Use yt-dlp to extract channel info
    try {
      // Handle both channel IDs and full URLs
      const channelUrl = channelId.startsWith('http') ? channelId : `https://www.youtube.com/channel/${channelId}`;
      const info = await this.extractChannelInfoWithYtDlp(channelUrl);
      return {
        id: channelId,
        title: info.title || 'Channel Title',
        description: info.description || '',
        subscriberCount: info.subscriberCount || 0,
        videoCount: info.videoCount || 0,
        viewCount: info.viewCount || 0
      };
    } catch (error) {
      logger.warn(`Channel info extraction failed:`, error);
      return {
        id: channelId,
        title: 'Channel Title',
        subscriberCount: 0,
        videoCount: 0,
        description: 'Channel description'
      };
    }
  }

  /**
   * Get videos from a channel
   */
  async getChannelVideos(channelId: string, options?: any): Promise<any> {
    const apiKey = process.env.YOUTUBE_API_KEY;
    const maxResults = options?.maxResults || 50;
    const order = options?.order || 'date';
    const pageToken = options?.pageToken;
    
    if (apiKey) {
      try {
        let url = `${this.baseUrl}/search?part=id,snippet&channelId=${channelId}&type=video&maxResults=${maxResults}&order=${order}&key=${apiKey}`;
        if (pageToken) {
          url += `&pageToken=${pageToken}`;
        }
        
        const response = await fetch(url);
        if (response.ok) {
          const data = await response.json() as any;
          
          const videos = data.items?.map((item: any) => ({
            videoId: item.id.videoId,
            title: item.snippet.title,
            description: item.snippet.description,
            publishedAt: item.snippet.publishedAt,
            thumbnails: item.snippet.thumbnails,
            channelId: item.snippet.channelId,
            channelTitle: item.snippet.channelTitle
          })) || [];
          
          return {
            videos,
            nextPageToken: data.nextPageToken || null,
            totalResults: data.pageInfo?.totalResults || videos.length
          };
        }
      } catch (error) {
        logger.warn(`YouTube API channel videos failed, using yt-dlp fallback:`, error);
      }
    }
    
    // Fallback: Use yt-dlp to extract channel videos
    try {
      // Handle both channel IDs and full URLs
      const channelUrl = channelId.startsWith('http') ? channelId : `https://www.youtube.com/channel/${channelId}`;
      const videos = await this.extractChannelVideosWithYtDlp(channelUrl, maxResults);
      return {
        videos,
        nextPageToken: null,
        totalResults: videos.length
      };
    } catch (error) {
      logger.warn(`Channel videos extraction failed:`, error);
      return {
        videos: [],
        nextPageToken: null,
        totalResults: 0
      };
    }
  }

  /**
   * Extract channel info using yt-dlp
   */
  private async extractChannelInfoWithYtDlp(channelUrl: string): Promise<any> {
    return new Promise((resolve, reject) => {
      const YT_DLP_PATH: string = process.env.SPIRALMEM_INSTALL_DIR 
        ? path.join(process.env.SPIRALMEM_INSTALL_DIR, 'venv', 'bin', 'yt-dlp')
        : 'yt-dlp';

      const ytDlpProcess = spawn(YT_DLP_PATH, [
        '--dump-json',
        '--no-download',
        '--no-warnings',
        '--playlist-end', '1', // Just get channel info, not videos
        '--user-agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        '--referer', 'https://www.youtube.com/',
        channelUrl
      ]);

      let output = '';
      let errorOutput = '';

      ytDlpProcess.stdout.on('data', (data: any) => {
        output += data.toString();
      });

      ytDlpProcess.stderr.on('data', (data: any) => {
        errorOutput += data.toString();
      });

      ytDlpProcess.on('close', (code: number) => {
        if (code !== 0) {
          reject(new Error(`yt-dlp channel info failed: ${errorOutput}`));
          return;
        }

        try {
          const lines = output.trim().split('\n');
          const info = JSON.parse(lines[0]);
          resolve({
            title: info.uploader || info.channel || 'Unknown Channel',
            description: info.description || '',
            subscriberCount: info.subscriber_count || 0,
            videoCount: info.video_count || 0,
            viewCount: info.view_count || 0
          });
        } catch (parseError) {
          reject(new Error(`Failed to parse channel info: ${parseError}`));
        }
      });

      ytDlpProcess.on('error', (error: any) => {
        reject(new Error(`Failed to run yt-dlp: ${error.message}`));
      });
    });
  }

  /**
   * Extract channel videos using yt-dlp with fast discovery
   */
  private async extractChannelVideosWithYtDlp(channelUrl: string, maxResults: number): Promise<any[]> {
    // First: Fast discovery using --extract-flat
    const fastVideos = await this.extractChannelVideosFlat(channelUrl, maxResults * 3); // Get more for filtering
    
    // Second: Get full metadata only for videos that might pass filtering
    const fullVideos = await this.extractDetailedVideoInfo(fastVideos.slice(0, maxResults * 2));
    
    return fullVideos;
  }

  /**
   * Fast channel video discovery using --extract-flat
   */
  private async extractChannelVideosFlat(channelUrl: string, maxResults: number): Promise<{id: string, title: string}[]> {
    return new Promise((resolve, reject) => {
      const YT_DLP_PATH: string = process.env.SPIRALMEM_INSTALL_DIR 
        ? path.join(process.env.SPIRALMEM_INSTALL_DIR, 'venv', 'bin', 'yt-dlp')
        : 'yt-dlp';

      const ytDlpProcess = spawn(YT_DLP_PATH, [
        '--flat-playlist',
        '--dump-json',
        '--no-download',
        '--no-warnings',
        '--playlist-end', maxResults.toString(),
        '--user-agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        '--referer', 'https://www.youtube.com/',
        channelUrl
      ]);

      let output = '';
      let errorOutput = '';

      ytDlpProcess.stdout.on('data', (data: any) => {
        output += data.toString();
      });

      ytDlpProcess.stderr.on('data', (data: any) => {
        errorOutput += data.toString();
      });

      ytDlpProcess.on('close', (code: number) => {
        if (code !== 0) {
          reject(new Error(`yt-dlp flat extraction failed: ${errorOutput}`));
          return;
        }

        try {
          const lines = output.trim().split('\n').filter(line => line.trim());
          const videos = lines.map(line => {
            const info = JSON.parse(line);
            return {
              id: info.id,
              title: info.title || 'Unknown Title'
            };
          }).filter(v => v.id); // Only keep videos with valid IDs
          
          logger.info(`Fast discovery found ${videos.length} videos from channel`);
          resolve(videos);
        } catch (parseError) {
          reject(new Error(`Failed to parse flat channel data: ${parseError}`));
        }
      });

      ytDlpProcess.on('error', (error: any) => {
        reject(new Error(`Failed to run yt-dlp flat extraction: ${error.message}`));
      });
    });
  }

  /**
   * Get detailed info for specific videos
   */
  private async extractDetailedVideoInfo(videos: {id: string, title: string}[]): Promise<any[]> {
    return new Promise((resolve, reject) => {
      const YT_DLP_PATH: string = process.env.SPIRALMEM_INSTALL_DIR 
        ? path.join(process.env.SPIRALMEM_INSTALL_DIR, 'venv', 'bin', 'yt-dlp')
        : 'yt-dlp';

      // Build URLs for selected videos
      const videoUrls = videos.map(v => `https://www.youtube.com/watch?v=${v.id}`);
      
      const ytDlpProcess = spawn(YT_DLP_PATH, [
        '--dump-json',
        '--no-download',
        '--no-warnings',
        '--user-agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        '--referer', 'https://www.youtube.com/',
        ...videoUrls
      ]);

      let output = '';
      let errorOutput = '';

      ytDlpProcess.stdout.on('data', (data: any) => {
        output += data.toString();
      });

      ytDlpProcess.stderr.on('data', (data: any) => {
        errorOutput += data.toString();
      });

      ytDlpProcess.on('close', (code: number) => {
        if (code !== 0) {
          logger.warn(`Some videos failed detailed extraction: ${errorOutput}`);
          // Don't reject, just return what we got
        }

        try {
          const lines = output.trim().split('\n').filter(line => line.trim());
          const videos = lines.map(line => {
            try {
              const info = JSON.parse(line);
              return {
                videoId: info.id,
                title: info.title || 'Unknown Title',
                description: info.description || '',
                publishedAt: info.upload_date ? this.formatUploadDate(info.upload_date) : new Date().toISOString(),
                duration: info.duration || 0,
                channelId: info.channel_id || '',
                channelTitle: info.uploader || info.channel || 'Unknown Channel'
              };
            } catch (e) {
              logger.warn(`Failed to parse video info: ${line.substring(0, 100)}...`);
              return null;
            }
          }).filter(v => v !== null);
          
          logger.info(`Extracted detailed info for ${videos.length} videos`);
          resolve(videos);
        } catch (parseError) {
          reject(new Error(`Failed to parse detailed video info: ${parseError}`));
        }
      });

      ytDlpProcess.on('error', (error: any) => {
        reject(new Error(`Failed to run yt-dlp for detailed info: ${error.message}`));
      });
    });
  }

  /**
   * Format upload date from yt-dlp format (YYYYMMDD) to ISO string
   */
  private formatUploadDate(uploadDate: string): string {
    if (uploadDate.length === 8) {
      const year = uploadDate.substring(0, 4);
      const month = uploadDate.substring(4, 6);
      const day = uploadDate.substring(6, 8);
      return new Date(`${year}-${month}-${day}`).toISOString();
    }
    return new Date().toISOString();
  }
}