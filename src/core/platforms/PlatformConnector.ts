import { 
  PlatformVideoInput, 
  PlatformVideo, 
  YouTubeVideoData, 
  YouTubeTranscript,
  PlatformTranscript,
  VideoDeepLink 
} from '../models/types.js';

export interface RateLimitInfo {
  requestsPerMinute: number;
  requestsPerHour: number;
  requestsPerDay: number;
  currentMinuteUsage: number;
  currentHourUsage: number;
  currentDayUsage: number;
  resetTimes: {
    nextMinute: Date;
    nextHour: Date;
    nextDay: Date;
  };
}

export interface PlatformVideoMetadata {
  videoId: string;
  title: string;
  description: string;
  duration: number;
  uploadDate: Date;
  thumbnailUrl: string;
  tags: string[];
  channelInfo: {
    id: string;
    name: string;
    subscriberCount?: number;
  };
  playlistInfo?: {
    id: string;
    title: string;
    position: number;
  };
  viewCount?: number;
  likeCount?: number;
  commentCount?: number;
  language?: string;
  category?: string;
  accessibility?: {
    hasClosedCaptions: boolean;
    hasAutoGeneratedCaptions: boolean;
    supportedLanguages: string[];
  };
}

export interface TranscriptData {
  videoId: string;
  language: string;
  segments: Array<{
    start: number;
    duration: number;
    text: string;
    confidence?: number;
  }>;
  isGenerated: boolean;
  source: 'platform' | 'api' | 'extracted';
}

export interface PlatformCapabilities {
  canExtractMetadata: boolean;
  canExtractTranscript: boolean;
  canGenerateDeepLinks: boolean;
  canAccessComments: boolean;
  canAccessPlaylists: boolean;
  canBatchProcess: boolean;
  supportsLiveContent: boolean;
  supportedLanguages: string[];
  maxBatchSize?: number;
}

/**
 * Abstract base class for all platform integrations
 * Provides common interface for video content extraction across platforms
 */
export abstract class PlatformConnector {
  abstract readonly platform: string;
  abstract readonly capabilities: PlatformCapabilities;
  
  protected apiCredentials: Record<string, any> = {};
  protected rateLimitInfo: RateLimitInfo;
  
  constructor(credentials?: Record<string, any>) {
    if (credentials) {
      this.apiCredentials = credentials;
    }
    this.rateLimitInfo = this.getDefaultRateLimits();
  }

  // Core abstract methods that each platform must implement
  abstract extractMetadata(url: string): Promise<PlatformVideoMetadata>;
  abstract extractTranscript(videoId: string, language?: string): Promise<TranscriptData>;
  abstract generateDeepLink(videoId: string, timestamp: number): string;
  abstract validateUrl(url: string): boolean;
  abstract extractVideoId(url: string): string;

  // Optional methods with default implementations
  async extractComments?(videoId: string, maxCount?: number): Promise<Array<{
    id: string;
    text: string;
    author: string;
    timestamp: Date;
    likeCount?: number;
    replies?: any[];
  }>>;

  async extractPlaylistVideos?(playlistId: string): Promise<string[]>;

  async searchVideos?(query: string, maxResults?: number): Promise<PlatformVideoMetadata[]>;

  // Rate limiting and API management
  async checkRateLimit(): Promise<boolean> {
    const now = new Date();
    
    // Reset counters if time windows have passed
    if (now >= this.rateLimitInfo.resetTimes.nextMinute) {
      this.rateLimitInfo.currentMinuteUsage = 0;
      this.rateLimitInfo.resetTimes.nextMinute = new Date(now.getTime() + 60000);
    }
    
    if (now >= this.rateLimitInfo.resetTimes.nextHour) {
      this.rateLimitInfo.currentHourUsage = 0;
      this.rateLimitInfo.resetTimes.nextHour = new Date(now.getTime() + 3600000);
    }
    
    if (now >= this.rateLimitInfo.resetTimes.nextDay) {
      this.rateLimitInfo.currentDayUsage = 0;
      this.rateLimitInfo.resetTimes.nextDay = new Date(now.getTime() + 86400000);
    }

    // Check if we're under all limits
    return (
      this.rateLimitInfo.currentMinuteUsage < this.rateLimitInfo.requestsPerMinute &&
      this.rateLimitInfo.currentHourUsage < this.rateLimitInfo.requestsPerHour &&
      this.rateLimitInfo.currentDayUsage < this.rateLimitInfo.requestsPerDay
    );
  }

  protected async recordApiCall(): Promise<void> {
    this.rateLimitInfo.currentMinuteUsage++;
    this.rateLimitInfo.currentHourUsage++;
    this.rateLimitInfo.currentDayUsage++;
  }

  protected async waitForRateLimit(): Promise<void> {
    if (!(await this.checkRateLimit())) {
      const now = Date.now();
      const waitTime = Math.min(
        this.rateLimitInfo.resetTimes.nextMinute.getTime() - now,
        this.rateLimitInfo.resetTimes.nextHour.getTime() - now,
        this.rateLimitInfo.resetTimes.nextDay.getTime() - now
      );
      
      if (waitTime > 0) {
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }

  // URL validation and parsing utilities
  protected validateAndParseUrl(url: string): { isValid: boolean; videoId?: string; timestamp?: number } {
    if (!this.validateUrl(url)) {
      return { isValid: false };
    }

    try {
      const videoId = this.extractVideoId(url);
      const timestamp = this.extractTimestampFromUrl(url);
      return { isValid: true, videoId, timestamp };
    } catch {
      return { isValid: false };
    }
  }

  protected extractTimestampFromUrl(url: string): number | undefined {
    // Common timestamp patterns across platforms
    const patterns = [
      /[&?]t=(\d+)s?/,           // ?t=123 or &t=123s
      /[&?]start=(\d+)/,         // ?start=123
      /[&?]time_continue=(\d+)/, // YouTube specific
      /#t=(\d+)/                 // #t=123
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return parseInt(match[1], 10);
      }
    }

    return undefined;
  }

  // Batch processing utilities
  async processBatch<T, R>(
    items: T[], 
    processor: (item: T) => Promise<R>, 
    batchSize: number = 10,
    delayMs: number = 1000
  ): Promise<R[]> {
    const results: R[] = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);
      const batchPromises = batch.map(processor);
      
      await this.waitForRateLimit();
      const batchResults = await Promise.allSettled(batchPromises);
      
      batchResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          results.push(result.value);
        } else {
          console.error(`Failed to process item ${i + index}:`, result.reason);
        }
      });

      // Add delay between batches to respect rate limits
      if (i + batchSize < items.length && delayMs > 0) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }

    return results;
  }

  // Configuration and credentials management
  updateCredentials(credentials: Record<string, any>): void {
    this.apiCredentials = { ...this.apiCredentials, ...credentials };
  }

  getCredentials(): Record<string, any> {
    return { ...this.apiCredentials };
  }

  updateRateLimits(rateLimits: Partial<RateLimitInfo>): void {
    this.rateLimitInfo = { ...this.rateLimitInfo, ...rateLimits };
  }

  getRateLimits(): RateLimitInfo {
    return { ...this.rateLimitInfo };
  }

  // Health check and diagnostics
  async healthCheck(): Promise<{
    platform: string;
    isHealthy: boolean;
    rateLimitStatus: {
      withinLimits: boolean;
      usage: {
        minute: number;
        hour: number;
        day: number;
      };
    };
    lastError?: string;
  }> {
    const withinLimits = await this.checkRateLimit();
    
    return {
      platform: this.platform,
      isHealthy: true, // Override in subclasses with actual health checks
      rateLimitStatus: {
        withinLimits,
        usage: {
          minute: this.rateLimitInfo.currentMinuteUsage,
          hour: this.rateLimitInfo.currentHourUsage,
          day: this.rateLimitInfo.currentDayUsage,
        }
      }
    };
  }

  // Default rate limits - override in subclasses
  protected getDefaultRateLimits(): RateLimitInfo {
    const now = new Date();
    return {
      requestsPerMinute: 60,
      requestsPerHour: 1000,
      requestsPerDay: 10000,
      currentMinuteUsage: 0,
      currentHourUsage: 0,
      currentDayUsage: 0,
      resetTimes: {
        nextMinute: new Date(now.getTime() + 60000),
        nextHour: new Date(now.getTime() + 3600000),
        nextDay: new Date(now.getTime() + 86400000),
      }
    };
  }

  // Error handling utilities
  protected handleApiError(error: any, context: string): Error {
    if (error.response?.status === 429) {
      return new Error(`Rate limit exceeded for ${this.platform} in ${context}`);
    } else if (error.response?.status === 401) {
      return new Error(`Authentication failed for ${this.platform} in ${context}`);
    } else if (error.response?.status === 403) {
      return new Error(`Access forbidden for ${this.platform} in ${context}`);
    } else if (error.response?.status === 404) {
      return new Error(`Resource not found on ${this.platform} in ${context}`);
    } else {
      return new Error(`API error for ${this.platform} in ${context}: ${error.message}`);
    }
  }
}